## [704. 二分查找](https://leetcode.cn/problems/binary-search/)

简单

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果 `target` 存在返回下标，否则返回 `-1`。

你必须编写一个具有 `O(log n)` 时间复杂度的算法。

**示例 1:**

**输入:** `nums` = [-1,0,3,5,9,12], `target` = 9
**输出:** 4
**解释:** 9 出现在 `nums` 中并且下标为 4

**示例 2:**

**输入:** `nums` = [-1,0,3,5,9,12], `target` = 2
**输出:** -1
**解释:** 2 不存在 `nums` 中因此返回 -1

**提示：**

1. 你可以假设 `nums` 中的所有元素是不重复的。
2. `n` 将在 `[1, 10000]`之间。
3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。

### java代码
```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while(left <= right){
            int middle = (left + right) / 2;
            if(nums[middle] < target){
                left = middle + 1;
            }else if(nums[middle] > target){
                right = middle - 1;
            }else{
                return middle;
            }
        }
        return -1;
    }
}
```

### python代码

```
class Solution:
    # 左闭右闭
    # def search(self, nums: List[int], target: int) -> int:
    #     left = 0
    #     right = len(nums)-1
    #     while(left <= right):
    #         middle = (left + right)//2
    #         if nums[middle] < target:
    #             left = middle + 1
    #         elif  nums[middle] > target:
    #             right = middle - 1
    #         else:
    #             return middle
    #     return -1

    # 左闭右开
    # def search(self, nums: List[int], target: int) -> int:
    #     left = 0
    #     right = len(nums)
    #     while(left < right):
    #         middle = (left + right)//2
    #         if nums[middle] < target:
    #             left = middle + 1
    #         elif  nums[middle] > target:
    #             right = middle 
    #         else:
    #             return middle
    #     return -1

    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            elif nums[mid] > target:
                # 右侧是开区间
                right = mid 
            else:
                return mid
        return -1
```

## [27. 移除元素](https://leetcode.cn/problems/remove-element/)

已解答

简单

提示

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95)** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。


**示例 1：**

**输入：** nums = [3,2,2,3], val = 3
**输出：** 2, nums = [2,2,_,_]
**解释：** 你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

**示例 2：**

**输入：** nums = [0,1,2,2,3,0,4,2], val = 2
**输出：** 5, nums = [0,1,4,0,3,_,_,_]
**解释：** 你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。

### java代码

```java

class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # fast,slow = 0,0
        # while (fast<len(nums)):
        #     if nums[fast] != val:
        #         nums[slow] = nums[fast]
        #         slow += 1
        #     fast += 1
        # return slow

        # 25-9-14
        fast,slow = 0,0
        while(fast<len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow +=1
            fast += 1
        return slow

```

### python代码
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        # fast,slow = 0,0
        # while (fast<len(nums)):
        #     if nums[fast] != val:
        #         nums[slow] = nums[fast]
        #         slow += 1
        #     fast += 1
        # return slow

        # 25-9-14
        fast,slow = 0,0
        while(fast<len(nums)):
            if nums[fast] != val:
                nums[slow] = nums[fast]
                slow +=1
            fast += 1
        return slow
```