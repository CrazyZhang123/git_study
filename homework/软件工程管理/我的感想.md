在项目管理、软件工程或组织行为学中，“焦油坑”常被用作**比喻**，形容一种看似可以轻易进入、但一旦陷入就难以脱身的困境。这个用法最早由著名计算机科学家**弗雷德里克·布鲁克斯**（Frederick P. Brooks）在其经典著作《人月神话》（The Mythical Man-Month）中提出。

> 他在书中写道：“**大型软件项目就像焦油坑——开始时进展顺利，但很快就会陷入复杂性、沟通问题和不断变化的需求中，越挣扎陷得越深。**” 

在这种比喻中，“焦油坑”代表：

- 项目复杂度迅速上升；
- 需求不断变更；
- 团队沟通不畅；
- 技术债务累积；
- 资源投入越来越多但产出越来越少。

开发者或管理者一旦“踏入”这样的项目，往往难以抽身，即使付出巨大努力也难以成功交付。

所以系统编程的进度安排背后的第一个错误的假设是:**一切都将运作良好，每一项任务仅花费它所“应该”花费的时间。**



冒昧地简化一下 Brooks 法则:
**向进度落后的项目中增加人手，只会使进度更加落后。**(Addingmanpower to a late software project makes it later.)



这就是除去了神话色彩的人月。项目的时间依赖于顺序上的限制，人员的最大数量依赖于独立子任务的数量。从这两个数值可以推算出进度表，该表安排的人员较少，花费的时间较长(唯一的风险是产品可能会过时)。相反，分派较多的人手，计划较短的时间，将无法得到可行的进度安排。总之，在众多软件项目中，缺乏合理的进度安排是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大。





### 第4 章贵族专制、民主政治和系统设计

作者主张，在系统设计中，概念完整性应该是最重要的考虑因素。也就是说，为了反映一系列连贯的设计思路，宁可省略一些不规则的特性和改进，也不提倡独立和无法整合的系统，哪怕它们其实包含着许多很好的设计。



**获得概念的完整性**
编程系统(软件)的目的是使计算机更加容易使用:



概念的完整性要求设计必须由一个人，或者非常少数互有默契的人员来实现。



对于非常大型的项目，将设计方法、体系结构方面的工作与具体实现相分离是获得概念完整性的强有力方法。



系统的体系结构(architecture)指的是完整和详细的用户接口说明。对于计算机，它是编程手册;对于编译器，它是语言手册;对于控制程序，它是语言和函数调用手册;对于整个系统，它是用户要完成自己全部工作所需参考的手册的集合。



必须仔细地将体系结构同实现区分开来。如同Blaauw所说的，“体系结构陈述的是发生了什么，而实现描述的是如何实现。”他举了一个简单的例子--时钟。它的结构包括表盘、指针和上发条的旋钮。当一个小孩知道了时钟的外表结构，他很容易从手表或者教堂上的时钟辨认时间。而时钟的实现，描述了表壳中的事物--很多种动力提供装置中的一种，以及众多控制精度方案的一种。



当建议由小型体系结构团队来编写计算机或编程系统的所有外部技术说明时，编程人员提出了三个反对意见:
该说明中的功能过于繁多，而对实际情况中的成本考虑比较少;
结构师获得了所有创造发明的快乐，剥夺了实现人员的创造力;
当体系结构的队伍缓慢工作时，很多实现人员只能空闲地坐着等待。
第一个问题确实是危险的，我们将在下一章中讨论这个问题，但其他的两个问题都是一些简单而纯粹的误解。正如我们前面所看到的，实现同样是一项高级的创造性活动。具体实现中创造和发明的机会，并不会因为指定了外部技术说明而大为减少，相反创造性活动会因为规范化而得到增强，整个产品也一样。



Blaauw指出，整个创造性活动包括了三个独立的阶段:体系结构(architecture)、设计实现(implementation)和物理实现(realization)。在实际情况中，它们往往可以同时开始和并发地进行。



概念的完整性的确要求系统只反映唯一的设计理念，用户所见的技术说明来自少数人的思想。实际工作被划分成体系结构、设计实现和物理实现，但这并不意味着该开发模式下的系统需要更长的时间来创建。

经验显示恰恰相反，整个系统将会开发得更快，所需要的测试时间将更少。同工作广泛的水平分割相比，垂直划分从根本上大大减少了劳动量使交流彻底地被简化，概念完整性得到了大幅提高。



### 第5章画蛇添足

The Second-System Effect



第二个系统是设计师们所设计的最危险的系统。而当他着手第三个或第四个系统时，先前的经验会相互验证，得到对此类系统通用特性的判断，而且系统之间的差异会帮助他识别出经验中不够通用的部分。
一种普遍倾向是过分地设计第二个系统，向系统添加很多修饰功能和想法，它们曾在第一个系统中被小心谨慎地放在次要位置。结果如同Ovid所述，是一个“大馅饼”。例如，后来被嵌入到7090的IBM 709系统的体系结构，709是对非常成功和简洁的704系统进行升级的二次开发项目。设计师将709的操作集合设计得如此丰富和充沛，以至于只有一半操作被客户经常使用。



结构师如何避免开发第二个系统所引起的后果，从而避免画蛇添足?是的，虽然他无法跳过二次系统，但他可以有意识地关注这个系统的特殊危险，运用特别的自我约束准则，来避免那些功能上的过于修饰:根据系统基本理念及目的变更，舍弃一些功能。



项目经理如何避免开发第二个系统所引起的后果，从而避免画蛇添足?他必须坚持至少拥有两个系统以上开发经验结构师的决定。同时，保持对特殊诱惑的警觉，他可以不断提出正确的问题，确保原则上的概念和目标在详细设计中得到完整的体现。



### 第6章 贯彻执行

Passing the Word



--手册文档化的规格说明
手册或者书面规格说明，是一个非常必要的工具，仅有文档是不够的。手册是产品的外部规格说明，它描述和规定了用户所见的每一个细节;同样地，它也是结构师主要的工作产物。

随着用户和实现人员反馈的增加，规格说明中难以使用和难以构建实现的地方不断被指出，规格说明也不断地被重复准备和修改。然而对实现人员而言，修改的阶段化是很重要的--在进度表上应该有带日期的版本信息。

手册不仅要描述包括所有界面在内的用户可见的一切，还要避免描述用户看不见的事物。后者是编程实现人员的工作范畴，而其设计和创造是不应该被限制的。体系结构设计人员必须为自己描述的任何特性准备一种实现方法，但是他不应该试图支配具体的实现过程。

规格说明的风格必须清晰、完整和准确。用户常常会单独提到某个定义，所以每条说明必须重复所有的基本要素，所有文字都要相互-致。这往往使手册读起来枯燥乏味，但是精确比生动更加重要。



**手册”是给所有人看的“产品说明书”，它只讲“用户看到什么、能做什么”，不讲“程序怎么写”，但要确保每个功能都有清晰、可执行的实现路径。**

#### 示例

假设我们要开发一个 **“在线书店系统”**，其中有一个功能叫：

> “用户可以搜索图书” 

###### ✅ 正确的手册写法（符合上述原则）：

> **功能名称：图书搜索**
>
> **1. 功能描述：**
> 用户可在首页顶部输入框中输入关键词，点击“搜索”按钮后，系统返回匹配的图书列表。
>
> **2. 输入要求：**
>
> - 搜索关键词长度：1~50个字符（含空格）。
> - 支持中文、英文、数字、标点符号。
> - 不区分大小写。
>
> **3. 输出要求：**
>
> - 返回结果按相关性排序（标题匹配度 > 作者匹配度 > 简介匹配度）。
> - 每页最多显示10本图书。
> - 显示内容包括：书名、作者、封面图、价格、评分。
>
> **4. 错误处理：**
>
> - 若无匹配结果，显示提示：“未找到相关图书”。
> - 若关键词为空，提示：“请输入搜索关键词”。
>
> **5. 实现建议：**
>
> - 前端需对输入进行长度校验。
> - 后端应使用全文检索引擎（如Elasticsearch）提升性能。
> - 排序算法应支持扩展，以便未来加入销量、上架时间等维度。
>
> **6. 版本信息：**
> v1.0 —— 2025年4月5日发布 

###### ❌ 错误的手册写法（违反原则）：

> “用户可以搜书，随便输点啥都行，系统会返回一些书。如果没找到就提示一下。后端自己想办法搞定。” 

→ 问题：

- 太模糊，没有边界。
- 没有输入输出规范。
- 没有错误处理。
- 没有版本控制。
- 描述了“实现”（“后端自己想办法”），但没给指导方向。





### 第 16 章没有银弹

软件工程中的根本和次要问题--
No Silver Bullet-Essence and Accident in Software Engineering



在未来的十年内，无论是在技术还是管理方法上都看不出有任何突破性的进步，能够保证在十年内大幅度地提高软件的生产率、可靠性和简洁性。



所有软件活动包括:==根本任务，即打造构成抽象软件实体的复杂概念结构;==次要任务，即使用编程语言表达这些抽象实体，在空间和时间限制下将它们映射成机器语言。软件生产率在近年来取得的巨大进步来自对人为障碍的突破，例如硬件的限制、笨拙的编程语言和机器时间的缺乏等，这些障碍使次要任务实施起来异常艰难。相对根本任务而言，软件工程师在次要任务上花费了多少时间和精力?除非它占了所有工作的9/10，否则即使全部次要任务的时间缩减到零，也不会带来生产率数量级上的提高。

我认为，**根本困难是固有的概念复杂性**，无论是任何时间，使用任何方法设计和实现软件的功能，它都存在。

**理解：**

> ##### 一、两个关键概念
>
> ###### 1. **根本任务（Essential Task）**
>
> - **定义**：设计和构建软件的**抽象概念结构**。
>
> - **内容**：包括理解用户需求、定义功能、设计模块关系、处理逻辑流程、确保一致性与正确性等。
>
> - **本质**：这是**智力密集型**的工作，涉及建模、推理、权衡和创新。
>
> - 举例
>
>   ：
>
>   - 设计一个电商系统的订单状态机（待支付 → 已支付 → 已发货 → 已完成 / 已取消）。
>   - 决定如何表示“用户权限”模型（RBAC？ABAC？）。
>   - 如何让多人协作编辑文档时数据不冲突（如 Google Docs 的协同算法）。
>
> > ✅ 这些都是“看不见的结构”，但决定了软件是否好用、可靠、可扩展。 
>
> ###### 2. **次要任务（Accidental Task）**
>
> - **定义**：将抽象概念**用编程语言实现**，并适配到具体硬件/运行环境中。
>
> - **内容**：写代码、调试语法错误、优化性能、处理内存管理、适配操作系统等。
>
> - **本质**：这是**技术实现层面**的工作，受工具和环境限制。
>
> - 举例
>
>   ：
>
>   - 用 Java 写一个类来实现订单状态。
>   - 调整数据库查询语句让响应时间从 2 秒降到 200 毫秒。
>   - 解决多线程下的竞态条件。
>
> > ⚠️ 这些工作虽然繁琐，但随着工具进步（如高级语言、IDE、自动内存管理），已经大大简化。 
>
> ##### 二、核心论点：**次要任务不是瓶颈**
>
> 作者指出：
>
> > “除非次要任务占了所有工作的 9/10，否则即使把它完全消除（时间=0），整体效率也无法提升一个数量级（即10倍）。” 
>
> ###### 📊 举个数字例子：
>
> 假设开发一个功能总共花 100 小时：
>
> - 如果 **根本任务占 80 小时**，次要任务占 20 小时。
> - 即使你发明了“自动编程神器”，让次要任务变成 0 小时，
> - 总时间也只从 100 小时 → 80 小时，**效率提升仅 25%**，远不到“数量级”（10倍）。
>
> 但如果你能让**根本任务**的效率提升（比如通过更好的建模工具、需求分析方法），那才可能带来革命性进步。
>
> ##### 三、现实意义
>
> - 过去几十年的进步
>
>   （如高级语言、框架、云服务）主要解决了
>
>   次要任务
>
>   的障碍：
>
>   - 不用手动管理内存（Java/Python）
>   - 不用写底层网络代码（HTTP 库）
>   - 不用买服务器（AWS）
>
> - 但软件依然难做
>
>   ，因为
>
>   根本任务没变简单
>
>   ：
>
>   - 用户需求依然模糊
>   - 系统复杂性依然高
>   - 逻辑错误依然难发现
>
> > 💡 所以，真正制约软件生产率的，不是“写代码慢”，而是“想不清楚到底要做什么、怎么做才对”。 
>
> ##### 四、类比理解
>
> 想象你要建造一座**复杂的桥梁**：
>
> - **根本任务** = 设计桥梁结构：跨度多少？承重多少？抗风抗震？材料如何分布？
> - **次要任务** = 用起重机吊装钢梁、拧螺丝、刷油漆。
>
> 即使你发明了“全自动机器人施工队”（次要任务=0），但如果**设计图纸本身有缺陷**（根本任务没做好），桥还是会塌。
>
> ###### ✅ 总结一句话：
>
> > **软件开发的核心挑战在于“想清楚”，而不是“写出来”。工具可以加速编码，但无法替你思考复杂逻辑和抽象结构。** 
>
> 这也是为什么优秀的软件工程师更像“建筑师”或“哲学家”，而不只是“码农”。



**大家熟悉的软件项目具有一些人狼的特性(至少在非技术经理看来)**，常常看似简单明了的东西，却有可能变成一个落后进度、超出预算、存在大量缺陷的怪物。因此，我们听到了近乎绝望的寻求银弹的呼唤，寻求一种可以使软件成本像计算机硬件成本一样迅速降低的尚方宝剑。



但是，我们看看近十年来的情况，没有发现银弹的踪迹。没有任何技术或管理上的进展，能够独立地许诺在生产率、可靠性或简洁性上取得数量级的提高。本章我们试图通过分析软件问题的本质和很多候选银弹的特征，来探索其原因。



其次，让我们了解中间的困难，来看看我们能期待什么样的软件技术产业发展速度。效仿亚里士多德，我将它们分成**根本的(essence)--软件特性中固有的困难**，**次要的(accident)--出现在目前生产中，但并非那些与生俱来的困难**



我认为软件开发中困难的部分是规格说明、设计和测试这些概念上的结构，而不是对概念进行表达和对实现逼真程度进行验证。



让我们来考虑现代软件系统中这些无法规避的内在特性:复杂度(根本属性)、可变性和不可见性。



如果回顾一下软件领域中取得的最富有成效的三次进步，我们会发现每一次都是解决了软件构建上的巨大困难，但是这些是**次要困难**，不是本质属性，也不是主要困难。同样，我们可以对每一次进步进行外推来了解它们的固有限制。

**高级语言**。毋庸置疑，软件生产率、可靠性和简洁性上最有力的突破是使用高级语言编程。大多数观察者相信开发生产率至少提高了5倍可靠性、简洁性和理解程度也大为提高。



**分时。**大多数观察者相信，分时在提高程序员的生产率和产品质量方面起到了很大作用，尽管它产生的进步不如高级语言。



**统一编程环境。**第一个集成开发环境--Unix和Interlisp，现在已经得到了广泛应用，并且由于整合的因素使生产率提高。为什么?
它们主要通过提供集成库、统一文件格式、管道和过滤器，解决了共同使用程序的次要困难。这样，概念性结构理论上的相互调用、提供输入和互相使用，在现实中可以非常容易地实现。



**银弹的希望**

- **Ada 和其他高级编程语言。**由于Ada采用的是抽象数据类型、层次结构的模块化理念所以Ada理念可能比语言本身更加先进。Ada使用设计来承载需求，作为这一过程的自然产物，它可能过于丰富了。不过，这并不是致命的，因为它的词汇子集可以解决学习问题，硬件的进展能提供更高的MIPS(每秒百万指令集)，减少编译的成本。

- **面向对象编程。**软件专业的一些学生坚持面向对象编程是当今若干新潮技术中最富有希望的。3我也是其中之一。达特茅斯的Mark Sherman提出，必须仔细地区别两个不同的概念:抽象数据类型和层次化类型后者也被称为类(class)。抽象数据类型的概念是指对象类型应该通过个名称、一系列合适的值和操作来定义,而不是理应被隐藏的存储结构。抽象数据类型的例子是 Ada包(以及私有类型)和Modula的模块。

- **人工智能**

  - 至于AI-2专家系统技术，应该用专门的章节来讨论。
    **专家系统。**人工智能领域最先进的、被最广泛使用的部分，是开发专家系统的技术。很多软件科学家正非常努力地工作着，想把这种技术应用在软件的开发环境中。[6]那么它的概念是什么，前景如何?

    专家系统是包含归纳推论引擎和规则基础的程序，它接收输入数据和假设条件，通过从基础规则推导逻辑结果，提出结论和建议，向用户展示前因后果，并解释最终的结果。推论引擎除了处理推理逻辑以外，通常还包括复杂逻辑或者概率数据和规则。
    ==对于解决相同的问题，这种系统明显比传统的程序算法要先进很多。==

    > **一、什么是专家系统？**
    >
    > 专家系统是一种**模拟人类专家决策能力**的人工智能程序。它通常由两个核心部分组成：
    >
    > 1. **知识库（Knowledge Base）**：包含大量由领域专家总结的“**规则**”（如“如果症状A和B同时出现，那么可能患有疾病C”）。
    > 2. **推理引擎（Inference Engine）**：根据用户输入的数据，运用逻辑推理（如正向链、反向链）从知识库中推导出结论。
    >
    > 此外，专家系统通常具备**解释功能**，即不仅能给出答案，还能说明“**为什么得出这个结论**”，这对用户理解和信任系统至关重要。
    >
    > > **专家系统 = 把老程序员的经验“写进电脑”，让新人也能像高手一样写代码、查错、做设计。** 
    > >
    > > 例如：**GitHub Copilot 的“建议”功能** —— 虽基于AI模型，但背后也有大量“专家规则”引导生成安全、规范的代码。

  - **自动编程**

    - Parnas 暗示这是一个用于魔咒的术语，本身的语义是不完整的，并断言:
      一句话，自动编程总是成为一种热情，使用现在并不可用的更高级语言编程的热情。

    - 意思是：人们总爱幻想“未来有一种超高级语言，只要说句话，电脑就全搞定”。但这只是“热情”（幻想），不是现实技术。

    - **简单总结（一句话让你记住）：**

      > **“自动编程”听起来很酷，但现实中它更像是个“许愿池”——大家总在许愿‘以后写代码不用人了’，可到现在也没人真能做到。Parnas 就是在泼冷水：别被这种幻想骗了，先搞清楚你要解决什么问题，再谈怎么自动解决它。”** 

  - **图形化编程**

  - **程序验证**

  - **环境和工具**



> **“没有银弹”意思是：在软件开发中，不存在一种“神奇技术”能一下子让开发效率翻倍、bug 消失、项目永不延期。** 

🧛 **什么是“银弹”？**

“银弹”（Silver Bullet）来自西方传说：**只有银做的子弹才能杀死狼人或吸血鬼**。
所以，“银弹”就成了“**一招制敌、一劳永逸的终极解决方案**”的代名词。

比如：

- 有人幻想：“只要用上 AI，程序员就不用加班了！”
- 有人相信：“只要换成最新框架，项目就能按时上线！”

这些想法，本质上就是在找“银弹”。

💡 但现实是：**软件开发的困难，来自它本身的“本质复杂性”**。

**总结：**

> **“没有银弹” = 软件开发很难，而且这种“难”是内生的、本质的。
> 别指望靠一个新技术、一个新工具就“一劳永逸”。
> 真正的解决方案，是耐心、沟通、经验和持续改进。** 

这句话不是让人绝望，而是**让人清醒**：
与其幻想“银弹”，不如脚踏实地把需求理清楚、把代码写干净、把团队协作好。



因为是根本困难所以就没有希望?1990年BradCox的一篇非常出色的论文“这就是银弹”(ThereIsaSilverBullet)，有说服力地指出可重用和可交互的构件开发是解决软件根本困难的一种方法。[8]我由衷地表示赞同。

