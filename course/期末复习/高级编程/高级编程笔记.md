
# 00-CourseOverview

## 一、编程语言的定义
- 本质：人与计算机的交流工具，用于实现计算、通信、世界建模
- 定位：计算机科学基础领域（与操作系统、体系结构并列）
- 现状：工业界/学术界活跃，新语言（Swift/Rust/Mojo等）、领域专用语言（R/Matlab等）持续涌现
- 思考：大模型时代，自然语言能否作为编程语言？


## 二、编程语言的核心关注点
1. **易用性**
   - 语言设计：语法、语义、抽象级
   - 工具支持：构建、调试、测试
   - 效率提升：领域专用语言（DSLs）
2. **高性能**
   - 实现方式：编译器/解释器、运行时
   - 优化方向：并行化
3. **软件质量（可靠/安全）**
   - 安全特性：类型安全、内存安全、并发安全
   - 验证手段：动静态检查、形式化验证
4. **理论基础**
   - 核心：形式化语义、形式化验证
   - 交叉学科：逻辑、代数、计算理论等



# 01-introduction

## 1.0、编程语言发展历史

机器语言、汇编语言、高级语言

## 1.1 编程语言简介

### 一、编程语言多样的原因
编程语言是“人与计算机的交流工具”，但：
1. **计算任务多样**：AI、图形动画、科学计算等场景需求不同；
2. **交流对象的诉求冲突**：
   - 人：要简单、高效写代码（开发效率）；
   - 机器：要少资源、快运行（性能）；
   - 还要兼顾程序正确（安全）——三者难以兼顾，需取舍，因此诞生不同语言。


### 二、编程语言的核心目标（3个）
- **效率**：代码易写、易读、开发快；
- **性能**：程序运行快、资源消耗少；
- **安全**：代码少出错、运行稳定。


### 三、编程语言的分类（按应用场景）
不同场景对应不同需求，语言会做不同取舍：

| 分类               | 代表语言       | 核心特点                                                                 |
|--------------------|----------------|--------------------------------------------------------------------------|
| 轻量业务开发（动态脚本） | Python、JS、Lua | **开发效率高（代码少、易写）**，解释执行；不追求性能/安全；语言开发容易、种类多。 |
| 重业务开发（静态类型App） | Java、Kotlin、**Go** | **追求效率、性能、安全的平衡**；静态类型（编译期查错）、自动内存管理；适配大规模代码。 |
| 系统编程           | C、C++、Rust    | **极致性能**，能和底层系统交互；对开发者能力要求高（Rust兼顾了安全）。 |


### 四、技术取舍的关键：动/静态选型
语言的“动/静态”（类型检查、内存管理）决定了它的特点：

1. **类型检查**：
   - 动态：约束少、开发快，但运行时检查，难优化、易出错；
   - 静态：约束多、规则严，但编译期查错，易优化。
2. **内存管理**：
   - 动态（GC）：开发者无感，但运行有开销；
   - 静态：内存使用严格，学习成本高，但性能/安全更好。

3. **争论**

   1. **核心辩论**：语言设计的最大分歧在于 “是否限制开发者行为”—— 一方认为语言应阻止开发者犯蠢（如 Java），另一方认为应允许开发者自由发挥（如 Perl），美国国防部（DoD）更倾向 Java。
      1. **动 / 静态类型的争论**：
         - 静态类型支持者：认为它能减少 bug、帮助编译器生成高效代码（确实如此）；
         - 动态类型支持者：认为静态类型限制了编程的灵活性（也确实如此）。

   1. **个人倾向**：作者偏好动态类型（反感语言对自己指手画脚），但承认静态类型也受聪明人青睐，因此这仍是一个未决的开放问题。



## 1.2 语言的分类

### 一、分类框架：按计算模型和编程风格
编程语言主要分为以下几类（还有逻辑式等）：函数式、命令式（过程式）、面向对象（OO）、逻辑式。


### 二、各类型核心特点
1. **函数式语言**
   - 思路：通过“函数定义+函数组合”完成计算，不关注“状态修改”，更像数学运算。
   - 示例（Python的lambda+map）：
     ```python
     add_one = lambda x: x + 1
     map([1,2,3], add_one)  # 输出[2,3,4]
     ```
   - 代表语言：Lisp、Haskell、ML。


2. **命令式（过程式）语言**
   - 思路：编排“命令序列”，**逐步修改机器状态**来完成计算（对应图灵机模型）。
   - 示例（C语言的循环修改数组）：
     ```c
     int mylist[] = {1,2,3};
     for (int i=0; i<3; i++) {
       mylist[i] = mylist[i] + 1;  // 逐个修改数组元素（状态）
     }
     ```
   - 代表语言：Algol、BASIC、Pascal、C。


3. **命令式 vs 函数式：以阶乘为例**
   
   - 命令式（C）：用循环+变量（`result`）记录中间状态，逐步累乘；
   - 函数式（Haskell）：直接对应数学定义，用递归表达，无“状态修改”：
     ```haskell
     factorial 0 = 1
     factorial n = n * factorial (n-1)
     ```


4. **面向对象（OO）语言**
   - 本质：**命令式的一种**，核心是“封装”——把“数据（属性）”和“计算（行为）”打包成“对象”。
   - 最初动机：用于科学仿真（模拟现实事物）。
   - 代表语言：Simula 67、Smalltalk、C++、Java。
   
   ![image-20251209151008694](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209151008808.png)


### 三、语言的演化关系
从根源语言衍生出不同分支：
- 函数式：Lisp → ML → Haskell；
- 命令式：Algol 60 → Pascal/C → Modula/C++；
- 面向对象：Smalltalk + C → Java。



## 1.3 语言的分类：按程序运行方式

先总结：
这部分是按“程序执行方式”给编程语言分类，核心分为静态编译型、动态解释型、字节码型三类，它们的差异在于“代码转机器指令的时机”，进而影响性能和灵活性。



### 一、分类核心：代码转机器指令的时机
计算机只能理解机器指令，编程语言需要通过不同方式将代码转换为机器指令，由此分为三类：


### 二、各类型特点
1. **静态编译型**
   - 执行流程：**开发阶段先编译** → 把代码直接转成对应硬件的机器指令 → 发布“编译好的机器码文件” → 运行时直接执行。
   - 类比：像电影“提前翻译配音”，发布后直接播放。
   - 优点：编译时可深度优化，**执行速度快**；
   - 缺点：编译后绑定硬件，代码**无法动态修改**（改代码需重新编译）；
   - 代表语言：C、C++、Go。


2. **动态解释型**
   - 执行流程：**运行阶段逐行解释** → 不提前编译，直接发布源代码 → 运行时由“解释器/虚拟机”逐行把代码转成机器指令并执行。
   - 类比：像“现场翻译”，边说边翻。
   - 优点：写完直接运行，**修改方便**（无需重新编译）；
   - 缺点：没有提前优化，**执行速度慢**；
   - 代表语言：Python、JavaScript、Ruby。


3. **字节码型（编译+解释结合）**
   - 执行流程：**开发阶段先编译成字节码**（一种中间代码，不绑定硬件） → 发布“字节码文件” → 运行时由“解释器/虚拟机”把字节码转成机器指令执行。
   - 特点：兼顾两者——编译字节码可做基础优化，字节码又能跨硬件运行；
   - 优缺点：性能和灵活性**介于编译型和解释型之间**；
   - 代表语言：Java（字节码+JVM）、Python（.pyc字节码）、C#。


### 三、三类方式对比表
| 类型       | 核心流程                | 性能 | 灵活性 | 代表语言     |
| ---------- | ----------------------- | ---- | ------ | ------------ |
| 静态编译型 | 提前编译为机器码        | 快   | 差     | C、C++、Go   |
| 动态解释型 | 运行时逐行解释          | 慢   | 好     | Python、JS   |
| 字节码型   | 编译为字节码+运行时解释 | 中等 | 中等   | Java、Python |



## 1.4 语言设计的关注

先总结：
这部分核心讲“好的编程语言”要平衡**人的需求（简单高效表达）和机器的需求（少资源完成计算）**，语言设计需围绕“抽象能力、可组合性、安全性、易用性与性能的取舍”展开，最终实现开发效率、程序质量的兼顾。



### 一、“好语言”的核心标准
好的编程语言要同时满足两方诉求：
- **对人**：能**简单、高效、正确**地表达计算任务（降低开发成本）；
- **对机器**：能用**最少的时间、资源**完成计算（提升运行效率）。


### 二、语言设计的核心关注点
语言设计需在多个维度做优化，核心包括：

#### 1. 良好的抽象能力
目标是**隐藏实现细节，让开发者专注业务逻辑**，常用手段：
- **声明式编程**：描述“想要什么”（如函数式的`map`），而非“怎么实现”（如命令式的循环）；
- **高阶函数**：允许函数作为参数/返回值（如`map`接收函数参数）；
- **多态**：泛型（如`Stack<String>`）、继承、重载，让代码适配不同场景；
- **模块化封装**：通过`private/public`等权限控制，隐藏内部实现（修改实现时，使用者无需改动）。

#### 2. 可组合性

>  **当实现发生改变时，使用者不需要相应做修改**

目标是**用基础元素构造复杂功能**，让代码更灵活、可复用：
- **数据组合**：支持复合数据类型（如结构体、对象）；
- **控制组合**：支持函数、协程等，把简单逻辑组合成复杂流程。


#### 3. 正确性与安全性
通过**限制编程自由度，减少出错机会**：
- **结构化编程**：用`if/loop/函数`替代混乱的`goto`，让代码逻辑更清晰；
- **类型系统**：
  - 静态类型（如Java、Rust）：编译期检查类型错误，提前规避问题；
  - 动态类型：运行时做类型检查。
  - 强类型：严格限制类型转换，避免隐式错误（弱类型如C/C++易出安全问题，新语言少用）；
  - 额外检查：动态检查（如下标越界）、内存安全（如垃圾回收、Rust的所有权机制）。


#### 4. 易用性、安全性、性能的取舍
这三者**难以同时兼顾，需根据场景做权衡**：
- 追求易用性：选动态类型、自动内存管理，但会牺牲性能/安全；
- 追求安全性：选静态类型、内存安全机制，但会牺牲易用性；
- 追求性能：选手工内存管理、指针运算，但会牺牲安全/易用性。


### 三、核心逻辑：平衡与取舍
语言设计没有“完美方案”，而是**根据目标场景，在抽象、安全、性能等维度做取舍**——比如Python优先易用性，C优先性能，Rust则在安全与性能间做了较好平衡。

要不要我帮你整理一份**不同场景下“好语言”的选型参考表**？



## 1.5 编程语言的实现，构成及发展

### 零、为什么新的语言不断出现？

因为语言需要不断演进。

**注意：**Java：每6个月一个新版本

### 一、编程语言的实现（技术落地维度）
编程语言的“实现”是指将语言设计转化为可运行程序的技术环节，核心关注3点：
1. **高性能运行**
   - 依赖技术：编译器（静态编译）、虚拟机/解释器（动态执行）、字节码、JIT（即时编译，兼顾编译/解释优势）、运行时（如垃圾回收管理内存）。
   - 目标：优化程序的性能、内存消耗、能耗、实时响应速度等。
2. **编译时长**：编译代码的耗时（影响开发效率，比如大型项目编译慢会降低迭代速度）。
3. **编译产物大小**：生成的二进制/字节码文件体积（比如嵌入式设备对文件大小有严格限制）。


### 二、“好语言”的其他因素（生态与工具维度）
语言的“好用程度”不仅看语法设计，还依赖配套生态：
- **库/框架**：丰富、易用的工具包（比如Python的数据分析库），能直接复用代码、降低开发成本；
- **开发工具**：IDE（代码编辑）、测试/调试工具（验证代码正确性）、包管理（管理依赖）等，提升开发效率。

### 三、编程语言的构成（狭义vs广义）

![image-20251209153833250](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209153833320.png)

- **狭义构成**：仅包含“语言定义（语法/语义规则）+ 编译前端/后端（代码转机器指令）+ 运行时（支撑程序运行的环境）”；
- **广义构成**：是覆盖“开发框架+三方库+工具链”的完整生态。
  （注：构建工业级语言是复杂工程——不仅要设计语法，还要配套生态工具）


### 四、编程语言的发展趋势
#### 1. 多范式编程（函数式+面向对象融合）
- 逻辑：两种范式优势互补——函数式擅长“用简单组件组合复杂功能”（靠高阶函数、泛型）；面向对象擅长“扩展复杂系统”（靠继承、动态配置）。
- 案例：Scala、Rust等新语言，以及Python、Java 8（新增lambda）等传统语言的升级。

#### 2. 安全增强

![image-20251209154056979](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209154057042.png)

- **空安全**：通过“非空类型”避免空引用错误（比如Kotlin中`String`是必非空，`String?`是可空，编译期就会检查错误）；
- **动态语言加静态检查**：动态类型语言（如Python）引入类型提示、TypeScript（JavaScript的静态类型版），在开发阶段提前发现错误。


#### 3. 可信系统语言
- 目标：让系统级编程更安全（传统C/C++易出内存错误）；
- 案例：Rust（靠所有权机制保障内存安全）、微软Verona（开发中）。


#### 4. 趋势预测
未来语言会向这些方向发展：
1. 安全系统编程（Rust、C/C++安全增强）；
2. 渐进式类型（融合动态/静态类型的优势）；
3. 并行/分布式编程支持（适配多核、分布式场景）；
4. 语言与软件工程工具深度结合；
5. AI辅助IDE（提升开发效率，但难有颠覆性突破）。

## 1.6 大模型时代，是否还需要编程语言？



### 一、核心结论：大模型时代，编程语言不会被取代，但形态会变化
大模型无法替代编程语言，因为编程语言同时承担“人机交流”和“人人交流”的双重作用，是软件工程的核心载体。

![image-20251209154309517](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209154309581.png)


### 二、为什么编程语言不会被自然语言取代？
编程语言的核心价值在于“无歧义性”，这是自然语言无法替代的：
1. **人机交流**：编程语言是人类向计算机传递精确指令的工具（计算机只能理解无歧义的机器语言，编程语言通过编译器转译为机器语言）；
2. **人人交流**：编程语言是软件工程师之间的“共享语言”——它是无歧义的数学化表达，是软件资产、智力成果的载体（类似科学家需要用数学公式交流，而非自然语言）。


### 三、大模型时代，编程语言的形态会如何变化？
当前编程语言更注重“易写”（降低开发成本），但大模型普及后：
- **代码生成的成本降低**（大模型可辅助写代码），但**代码的审核、测试、验证变得更重要**；
- **编程语言的设计会转向“易读”（远大于易写）**——让代码更容易被人理解、审查，适配大模型时代的软件工程流程（编码→测试→审核→重构的全链路需要“可读的代码”作为基础）。

![image-20251209154732086](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209154732149.png)



# 02 CangjieOverview

## 一、hello 仓颉

```c
main() {
println("你好，仓颉")
}

> cjc hello.cj -o hello
> ./hello
你好，仓颉
```

**项目常用命令：**

| 命令                         | 说明                                            |
| ---------------------------- | ----------------------------------------------- |
| `cjpm init`                  | 初始化一个新的仓颉项目，生成`cjpm.toml`配置文件 |
| `cjpm add <package-name>`    | 安装指定包并添加到依赖（如`cjpm add http`）     |
| `cjpm install`               | 根据`cjpm.toml`安装所有依赖                     |
| `cjpm update`                | 更新已安装的包到最新兼容版本                    |
| `cjpm remove <package-name>` | 移除指定依赖包                                  |
| `cjpm list`                  | 列出当前项目已安装的包                          |
| `cjpm build`                 | 构建项目（部分版本可能仍使用                    |

## 二、变量


**可变变量**： var name: type = expr
**不可变变量**：let name: type = expr
**常量**：const name: type = exprconst
当初始值具有明确类型时，可以省略变量类型标注，编译器会自动推断出变量类型。

| 关键字 | 含义           | 是否可重新赋值 |
| ------ | -------------- | -------------- |
| `let`  | 声明不可变变量 | ❌ 不可         |
| `var`  | 声明可变变量   | ✅ 可以         |

示例

```c
let a = 5
var b = 10

b = 20   // ✅ OK
// a = 6 // ❌ 编译错误
```

## 三、类型

![image.png|500](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235315812.png)


相同的数据，赋予不同的类型/协议，解析和操作结果并不相同。

### 1、基础数据类型

![image.png](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235316772.png)

| 语法    | 含义         | 是否包含右端点 |
| ------- | ------------ | -------------- |
| `a..b`  | 左闭右开区间 | ❌ 不包含`b`    |
| `a..=b` | 左闭右闭区间 | ✅ 包含`b`      |

### 2、表达式

#### (1) 管道操作符

let result = data |> fn1 |> fn2 |> fn3

> 使用了 **管道操作符（Pipe Operator）`|>`**，这是一种常见的函数式编程语法，在仓颉语言（Cangjie）、Elixir、F#、OCaml、以及 JavaScript 的提案中都有类似设计。

等价于  let result = fn3(fn2(fn1(data)))

#### (2) case

let color = Color.Red(100)

```c
let result = match (color) {
    case Red(value)   => value + 10          // value = 100，结果 110
    case Green(text)  => text.length()
    case _            => 0
}
// result == 110
```

- `match (color)`：对变量 `color` 进行模式匹配。
- 每个 `case` 尝试将 `color` 与某种**构造器**（如 `Red`、`Green`）匹配。
- 如果匹配成功，会**解构**（extract）出其中的值（如 `value`），并在 `=>` 右侧的代码块中使用。
- `case _` 是**通配符**，匹配所有未被前面 case 覆盖的情况（类似 `else` 或 `default`）。

#### (3)if 表达式

如果exprBool 取值为true，将执行if 分支，反之执行else 分支。如果执行了某个分支或没有可选分支，都会跳出if 表达式并执行后续代码。
如果if 表达式**具有else 代码块**，==则if 表达式的值就等于所执行代码块最后一个表达式的值。其他情况的if 表达式类型为Unit。==
![image.png|400](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235316452.png)

#### (4)while 表达式

![image.png](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235316064.png)

#### (5) for-in 表达式

遍历对象的类型**需要实现迭代器接口Iterable\<T\>**，运行时，将逐次调用迭代器取值并执行循环体,在循环体中可以通过循环变量引用对应值。

规定for-in 表达式的类型是Unit。
![image.png|600](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235316966.png) 

示例

```c
// 可使用where 引导一个Bool 表达式，取值为true 才会执行循环体。
for (i in 0..10 where i % 2 == 1) {
println(i)
}
```

## 四、函数

### 1、定义函数

参数主要分为两种基本类型：**普通参数** 和 **命名参数**。第三种是前两者的组合。

函数类型的表达方式() -> type

函数不仅可以被调用，还可以作为值去使用，如赋值给变量、作为函数的参数和返回值等。

#### 1. 普通参数

- **代码表示**： `params_normal := name: type, name: type`
- **解释**：
  - 这是最常见的参数形式，也称为**位置参数**。
  - 在调用函数或方法时，传入的实参**必须严格按照形参定义的顺序**进行匹配。
  - 例如，如果定义为 `greet(name: String, age: Int)`，调用时必须写 `greet("Alice", 25)`，而不能打乱顺序。

#### 2. 命名参数

- **代码表示**： `params_named := name!: type, name!: type`

- **解释**：
  - 这种参数通过名字来传递，而不是位置。在定义时，参数名后面带有一个感叹号 `!`作为标识。
  - 在调用时，可以显式地指定参数名，从而**允许打乱传递顺序**，提高了代码的可读性和灵活性。
  - 例如，如果定义为 `connect(timeout!: Int, url!: String)`，调用时可以写 `connect(url: "example.com", timeout: 30)`。

#### 3. 综合参数

- **代码表示**： `params := params_normal ?, params_named ?`

- **解释**：
  - 在实际的函数定义中，可以同时包含普通参数和命名参数。
    - 这里的问号 `?`表示“零个或一个”，即普通参数部分和命名参数部分都是可选的。一个合法的参数列表可以是：只有普通参数、只有命名参数，或者两者都有。

#### 4、参数顺序

> **命名参数只能写在非命名参数之后**

这意味着在一个参数列表中：**必须先列出所有的普通参数（位置参数）**，**然后再列出命名参数**。

### 2、调用函数

![image.png](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235317108.png)

### 3、lambda 表达式

lambda 表达式可以让函数的创建和使用更加灵活， lambda 表达式的值就是一个匿名函数。
lambda 表达式中**无须标注返回值类型，仓颉编译器会从上下文中自动推导。**
{ params => blockfunc }

![image.png](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235042404.png)

## 五、枚举

### 1、定义与实例化

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235317969.png" alt="image.png" style="zoom:80%;" />

#### 1.1 基本结构

- `item`：枚举的“枚举项”
- `item ( | item )*`：第一个 item 后面可以跟任意多个 `| item`
  - 换句话说：
    **枚举项由 `|` 分隔**
- `(decl_func | decl_prop)*`：枚举后面可以写“成员函数”或“成员属性”（可选）

#### 1.2  item（枚举项）的定义

无参枚举项

```
Red
Green
Blue
```

✔ 有参枚举项（类似 Rust、Swift 的带参数枚举）

```
Point(x, y)
Error(message)
```

#### 1.3 带属性、带函数的 enum

你图中最后部分 `(decl_func | decl_prop)*` 就是允许下面这样写：

```
// 定义枚举类型：Fruit
enum Fruit {
  // 枚举项：无参 + 有参
  Apple                // 无参枚举项
  Banana(Int, String)  // 有参枚举项（需要：重量(Int)+产地(String)）
  
  // 成员函数：获取水果描述
  func getDesc(): String {
    match this {
      case Apple:
        return "这是苹果"
      case Banana(weight, place):
        return "这是来自${place}、重${weight}g的香蕉"
    }
  }
  
  // 成员属性：是否是热带水果
  prop isTropical: Bool {
    get {
      match this {
        case Apple: return false
        case Banana(_, place): return place == "海南"
      }
    }
  }
}
```

**示例调用代码**

```javascript
// 创建枚举实例
let apple = Fruit.Apple
let banana = Fruit.Banana(150, "海南")

// 调用成员函数
print(apple.getDesc())       // 输出：这是苹果
print(banana.getDesc())      // 输出：这是来自海南、重150g的香蕉

// 访问成员属性
print(apple.isTropical)      // 输出：false
print(banana.isTropical)     // 输出：true
```

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235323392.png" alt="image-20251209202537938" style="zoom: 75%;" />

#### 1.4 一个 struct 

定义一个叫 `name` 的结构体，它里面可以有：

- **若干个构造函数**（`constructor*`，星号表示 0 个或多个）
- **成员变量**（`decl_var`）
- **成员函数**（`decl_func`）
- **成员属性**（`decl_prop`）

#### 1.5 两种构造函数：普通构造 & 主构造

**1、普通构造**

理解成：“一个叫 `init` 的函数，用来初始化结构体”。

举个例子：

```
struct Point {
    var x: Float64
    var y: Float64

    init(x: Float64, y: Float64) {
        this.x = x
        this.y = y
        println("Create a point: (${x}, ${y})")
    }
}
```

**2、主构造函数**

这个是 **“语法糖版的构造函数”**：
在小括号里，**直接声明成员变量**，同时完成“定义 + 传参 + 初始化”。

```
struct Point {
    Point(let x: Float64, let y: Float64) {
        println("Create a point: (${x}, ${y})")
    }
}

main() {
    let p = Point(3.0, 4.0)        // 创建 Point 实例
    println("Visit the point: (${p.x}, ${p.y})")  // 访问成员
}
```

- `Point` 这个函数就是 **主构造函数**

- `let x: Float64, let y: Float64` 不是普通参数，而是 **成员变量声明**

  - 等价于在 struct 里写：

    ```
    var x: Float64
    var y: Float64
    ```

    然后又在构造函数里写 `this.x = x`、`this.y = y`

- 也就是说：**`decl_vars` 把“成员变量定义 + 初始化”写在一块，减少样板代码**
  这就是右下角那句注释在说的意思。

### 2、成员访问规则

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209173228596.png" alt="image.png" style="zoom: 80%;" />

### 3、match 表达式

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235321858.png" alt="image.png" style="zoom:80%;" />
应用实例表达式计算
<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209173230240.png" alt="image.png" style="zoom: 67%;" />

这里采用默认优先级，运算符重载是对let x=表达式的运算符进行重载；它让我们可以用写数学公式的自然方式（如 `1.2 + 3.4 * 2.0`）来“搭建”表达式树，而不是繁琐地直接构造节点（如 `Add(Num(1.2), Mul(Num(3.4), Num(2.0)))`）。

所以，当程序执行 `let x = Num(1.2) + Num(3.4) * Num(2.0) ...`这行代码时，**并没有进行数学计算**，它只是在内存中构建出了上面那棵复杂的“表达式树”，并把树根赋值给了变量 `x`。

a.calc() + b.calc()才是真正的运算。

### 4、Option

在部分应用场景中，**一个变量无法在整个生命周期内都被赋予有效值**，例如存在异常情况或可选的初始化设计等，为了高效且安全地表达这种“或有或无”的值，仓颉语言提供了Option 类型。

![image.png](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235326145.png)



## 六、类

### 1、定义与实例化

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235324225.png" alt="image-20251209205304779" style="zoom:67%;" />

结构几乎和结构体一模一样。

### 2、成员访问规则

![image-20251209205349147](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235327880.png)

相比结构体，成员访问规则多了一个`protected`

```
p2.set(1.0, 2.0)
```

因为 `p1` 与 `p2` 是同一个对象：

- 修改 p2.x → 1.0
- 修改 p2.y → 2.0

也等价于修改 p1。

### 3、继承

![image-20251209210520485](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235054769.png)



------

#### ✅ **一、open class 才能被继承**

仓颉里类**默认不能被继承**，
 必须写成：

```cangjie
open class A { ... }
```

否则别的类没法继承。

继承写法：

```cangjie
class B <: A { ... }
```

意思是：

- **B 是 A 的子类**
- **A 是 B 的父类**

子类可以访问父类的 **非 private 成员**。

------

#### ✅ **二、子类可以覆盖父类的 open 成员**

父类中的方法如果要让子类重写，必须标记为：

```cangjie
open func traverse() { ... }
```

子类中直接写同名方法就代表覆盖（override）：

```cangjie
public func traverse() { 
    // 新实现
}
```

运行时如果类型是 NodeA，却指向 NodeB 实例，会调用子类版本 → **多态**。

------

#### ✅ **三、super 调用父类构造 / 父类方法**

子类构造函数中可以通过 `super` 访问父类构造：

```cangjie
super(value, left: left, right: right)
```

也可用 `super.method()` 调父类方法。

------

#### ✅ **四、示例说明了“遍历函数被覆盖后的效果”**

父类 `NodeA.traverse()` 实现 **中序遍历**：

```
left -> self -> right
```

子类 `NodeB.traverse()` 覆盖后实现 **前序遍历**：

```
self -> left -> right
```

当树的部分节点是 NodeA、部分节点是 NodeB 时：

- 程序会根据节点实际类型自动调用对应版本的 traverse()
- 最终序列是多态组合的结果（示例输出：`CDBAEFG`）

------

#### ✨ **一句话总结**

> **open class 才能继承；
> 子类可以覆盖父类的 open 方法；
> 覆盖方法在运行时根据实际类型动态选择，实现多态；
> super 用于调用父类构造或方法。**



### 4、属性

![image-20251209214302214](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235334218.png)

```
# public 表示：这个属性可以被类外部访问
# mut 表示：属性是可变的（mutable），因此 set(name) 可以定义 setter。
# var 普通成员变量（没有 getter/setter）
# prop  声明一个属性：通过 get() / set() 控制读写
# param: Int64 —— 属性名称与属性类型

# 定义一个名字叫 param、类型为 Int64 的公共可变属性，它具有自定义的 getter 和 setter 函数。
public mut prop param: Int64 {
    set(number) {
        value = number      // 1. 更新当前节点的 value
        update()            // 2. 自己执行更新方法
        left?.param = number / 2     // 3. 递归更新左孩子
        right?.param = number / 2    // 4. 递归更新右孩子
    }

    get() { value }         // 读取 param 时返回 value
}
```

**写入 `root.param = 128` 会触发：**

1. 当前节点 value = 128
2. 调用 update()
3. 左节点的 param = 64
4. 右节点的 param = 64
5. 左节点又会继续向下触发更新……

这就是**递归更新树节点**的机制。

### 5、值类型与引用类型

<img src="https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235331681.png" alt="image-20251209214547533" style="zoom:67%;" />

#### 🎯 一句话先总结

> **栈（Stack）是用来存放“生命周期短、大小固定的数据”；
> 堆（Heap）是用来存放“生命周期不确定、大小不固定的数据”。**

而仓颉语言中：

- **struct、Int、Float、VArray** = 值类型 → 放栈（或寄存器）
- **class、Array、复杂对象** = 引用类型 → 放堆

------

#### ✨ 一、什么是“值类型”？

图左边说：

> “编译器在栈上为变量分配一块内存 S1/S2，变量只绑定这些内存区域。”

它的特点是：

✔ **每个变量都独立拥有自己的数据副本**

比如：

```cangjie
var p1 = Point(1.0, 2.0)
var p2 = p1
p2.x = 3
```

因为 **Point 是 struct（值类型）**，所以：

- **p1 和 p2 是两块不同栈内存，互不影响**
- 修改 p2 不影响 p1

图示中绿色线表示：“变量 == 自己那块数据”。

📌 这类数据通常放在：

- **CPU 寄存器**
- **栈（Stack）**
- 全局数据区（Global）

因为它们生命周期短、大小固定。

------

#### ✨ 二、什么是“引用类型”？

图右侧展示了：

```cangjie
class Point { ... }
var p1 = Point(1.0, 2.0)
var p2 = p1
```

class 是**引用类型**：

- **对象本体**放在 **堆（Heap）**
- 变量 p1、p2 放在 **栈（Stack）** 上
- 但它们存储的不是对象，而是**指向堆的地址（引用）**

所以修改：

```cangjie
p2.x = 3
```

等同于修改堆内数据，
 因此 **p1.x 也变成 3**。

图里红色线条表示：“变量 → 指向堆内对象”。

------

#### 🌟 三、堆（Heap）到底是什么？什么时候用？

图中蓝色的 Heap 区域表示：

> **堆是程序运行时用来存放生命周期不确定、大小不固定的数据的区域。**

✔ 堆用于：

- class 实例对象（Node、Point…）
- 大的数组 / 动态集合
- 不知道要活多久的值
- 多处共享的数据

✔ 堆由运行时（runtime）自动管理（垃圾回收或引用计数）

你不需要手动 free 内存。

------

#### 🌟 四、栈（Stack）是什么？什么时候用？

图里 Stack 区域表示：

> **栈是函数调用时自动推入/弹出的临时存储区，速度极快。**

✔ 栈用于：

- 函数内的临时变量
- struct、Int、Float 等值类型实例
- 指向堆对象的引用（class 的地址）

特点：

- 自动回收
- 空间小但速度极快
- 大小固定的数据才能放

------

#### 🌟 五、为什么 struct 放栈？class 放堆？

因为：

✔ struct = 值语义 → 拷贝、独立 → 栈更合适

运行效率高，适合小对象（Point、Vector、Matrix 等）。

------

✔ class = 引用语义 → 共享对象 → 堆更合适

对象可能被多个地方引用，必须保证数据存储在统一位置。

------

#### 🌟 六、图中例子完整解释（最核心）

左图：struct Point

```
var p1 = Point(1.0, 2.0)
var p2 = p1
```

→ Stack 上出现 S1、S2 两份数据
 → 修改 p2 不影响 p1
 → 值类型

右图：class Point

```
var p1 = Point(1.0, 2.0)   // S1 指向堆 H
var p2 = p1               // S2 也指向 H
```

→ 修改 p2.x 会修改堆中的数据
 → p1 访问的也是堆中数据
 → 引用类型

------

#### 🎯 七、最简单的区分方法（非常实用）

| 用途                 | 推荐类型 | 存储位置 |
| -------------------- | -------- | -------- |
| 小而简单，不需要共享 | struct   | 栈       |
| 大对象，需要共享     | class    | 堆       |
| 不想被复制，想共享   | class    | 堆       |
| 强调快速、轻量       | struct   | 栈       |

------

#### 🧠 最后一句话帮助你记住：

> **栈 = 放短命、轻量、独立的数据（值类型）。
> 堆 = 放长命、共享、复杂的数据（引用类型）。**



## 七、接口与扩展

### 1、接口

![image-20251209232943159](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235332892.png)

**1. 核心概念：Slot 是“信号源接口”**

所有信号模块都实现同一个接口：

```
interface Slot {
    func compute(t: Float64): Float64
}

```

**意义：**

> Slot = 一个能根据时间 t 产生信号的对象。

换句话说：
**只要能 compute(t)，你就是一个信号源。**

### 2、实现接口

![image-20251209233208381](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235057732.png)

#### **1. 扩展 Float64 也实现 Slot（常量信号源）**

```
extend Float64 <: Slot {
    public func compute(t: Float64): Float64 {
        return this
    }
}

```

**意思：**

- float 值本身就是一个“信号源”
- compute(t) 总是返回这个值（常量信号）

**例如：**

```
let c = 1.0
c.compute(t) == 1.0
```

所以 **1.0** 可以直接参与信号图运算。

#### 2.**“为什么要用 `< <` 和 `>>` 连接？它到底代表了什么？有什么意义？”**

你的问题非常关键，因为这个示例不是在讲普通类之间的关系，而是在构建一个：

**🧠 信号流图（Signal Flow Graph）——一个“可组合的信号系统 DSL”**

`<<` 和 `>>` **不是随机发明的语法糖**，而是为了让“信号从一个模块流向下一个模块”变得**直观、可读、可扩展**。

你要把这些类想象成：

- **常量信号源**
- **波形信号源**（sin）
- **乘法器**（Mul）
- **积分器**（Integrator）

这些都是 **信号模块**。

信号要“流动”——才能形成系统。

------

##### 🎯 一句话解释连接的意义

> **`a >> b` 的意义是：把信号 a 连接到模块 b 的输入上，让 b 的输出依赖 a。**

也就是：

```
b.input = a
```

这是构建信号处理链路的关键。

------

##### 🔧 为什么要用操作符来连接？

因为信号流图通常用箭头表示：

```
 a ---> b ---> c
```

如果用普通语句写，你就必须写：

```
b.setInput(a)
c.setInput(b)
```

但如果用操作符：

```
a >> b >> c
```

你马上能看出：

- 信号从 a 流向 b
- 再从 b 流向 c

**这是 DSL（领域特定语言）设计，重视可读性。**

------

#### 🎛 再看这个例子里的意义

main 中这一行：

```cangjie
let left = 1.0 >> Integrator(DT)
```

可视化成：

```
1.0 -----> Integrator ---> 输出 left(t)
```

表示：

- 信号“1.0”进入积分器
- 积分器输出一个信号 left(t) = ∫ 1 dt = t

你得到一个 **随时间增长的信号**。

------

##### 📡 再看完整的信号链：

```cangjie
let left  = 1.0 >> Integrator(DT)
let right = Wave(...)
let flow  = Mul(left, right) >> Integrator(DT)
```

可视化成图：

```
                +-------------+
1.0 ---> ∫ ---> | left(t)     |
                +-------------+

Wave ----------+
               | x (Mul) ---> ∫ ---> flow(t)
left ----------+
```

`left` 和 `right` 两个信号进入乘法器 Mul：

```
Mul(left, right).compute(t) = left(t) * right(t)
```

这个乘积信号再进入另一个积分器，得到最终输出 flow(t)。

这是一个典型的：

##### **信号处理链路（Signal Pipeline）**

就像搭积木一样搭模块。

------

##### 🔥 为什么 `<<` 和 `>>` 要成对存在？

因为这是一个“可写成链式”的信号流 DSL。

实际功能完全等价：

```
b << a
a >> b
```

它们都表示：

```
b.input = a
```

但 DSL 允许你写：

```
signal >> Integrator >> Mul >> Integrator
```

这种写法：

- 更线性
- 更符合信号从左到右流动的直觉
- 更适合构建复杂图

就像 UNIX 管道：

```
cat file | grep keyword | sort
```

但这是信号处理管道。

------

##### 🧩 最关键的一点：**连接的意义不是语法技巧，而是定义“模块如何组合”的方式**

你必须理解：

> **每个 compute(t) 都是一个信号模块，连接表示数据依赖关系，形成信号网络。**

像函数式数据流：

```
f(t) = ∫ (t * sin(t))
```

用图表示：

```
t → sin(t) → * → ∫
```

用仓颉表示：

```
1.0 >> Integrator    // left = t
Wave(...)            // sin(t)
Mul(left, right)
>> Integrator        // 最终积分
```

这就是 DSL 的全部意义。

### 3、扩展

![image-20251209234849493](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251209235334949.png)

下面我用**从 Markdown 3 级标题（###）开始**的结构，清晰解释这一页内容：**仓颉语言中的泛型（Type Parameter / Generic Type）**。

------

#### 3.1💡 泛型的核心思想

> **泛型 = 参数化类型。允许在定义结构时写“类型参数”，使用时再指定具体的类型。**

优点：

- 让同一套代码适用于多种类型
- 不用为 Int/Rune/String 分别写多个版本
- 提高复用、减少重复代码
- 类型安全（编译器会检查）

------

#### 3.2 泛型类型的定义：`struct Node<T>`

图左侧代码：

```cangjie
struct Node<T> where T <: ToString {
    public Node(var value: T,
                let left!: ?Node<T> = None,
                let right!: ?Node<T> = None) {}

    public func traverse(): Unit {
        left?.traverse()
        print(value)
        right?.traverse()
    }
}
```

逐条解释：

##### 1. `Node<T>`

Node 是一个“参数化类型”，T 是一个类型参数。
 使用 Node 时需要告诉它 T 是什么类型，比如 Node、Node。

##### 2. `where T <: ToString`

类型约束：

> **T 必须实现 ToString 接口（能转换为字符串）。**

这是为了让 `print(value)` 能合法。

##### 3. `value: T`

节点的数据类型是 T（泛型）。
 所以你可以用：

- T = Rune → 字符二叉树
- T = Int64 → 数值二叉树
- T = 自定义类型
- 只要符合 ToString

------

#### 3.3通过泛型构造不同的类型实例

右侧 main 里有两个不同类型的树：

------

##### **1️⃣ Node：字符树**

```cangjie
var tree1 = Node('A',
    left: Node('B', left: Node('C', right: Node('D'))),
    right: Node('E', left: Node('F'), right: Node('G')))
```

树结构：

```
      A
    /   \
   B     E
  / \   / \
 C   D F   G
```

调用 `tree1.traverse()` 输出字符的中序遍历：

```
C D B A F E G
```

（图里显示的是：CDBAFEG）

------

##### **2️⃣ Node：整数树**

```cangjie
var tree2 = Node(1,
    left: Node(2, left: Node(3), right: Node(4)),
    right: Node(5, left: Node(6), right: Node(7)))
```

结构类似，换成数字：

```
      1
    /   \
   2     5
  / \   / \
 3  4  6  7
```

输出：

```
3 2 4 1 6 5 7
```

图中结果是：

```
3421657
```

------

#### 3.4 为什么泛型重要？（本页想强调的重点）

本页其实强调三点：

##### **① 泛型可以让一份代码适配多个类型**

比如 Node：

- T = Rune → 字符树
- T = Int64 → 数值树
- T = 自定义对象 → 对象树

你甚至可以写：

```cangjie
Node<Person>
Node<Coordinate>
Node<Vector3>
```

只要它们实现 ToString。

------

##### **② 泛型支持“类型约束”**

```cangjie
where T <: ToString
```

保证：

- T 必须能被打印
- 类型是安全、可靠的
- 避免运行时报错

------

##### **③ 泛型可用于 struct、class、enum、接口**

图上说明：

> “仓颉中可以泛型化的类型有 **函数、结构体、类、枚举、接口**。”

意思是泛型是语言的一等公民。



## 八、异常处理

### 1、异常类型

![image-20251210000436793](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210000436962.png)

### 2、构建和抛出异常

![image-20251210000535115](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210000535265.png)

### 3、异常处理

![image-20251210000606141](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210000606272.png)

![image-20251210000700652](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210000700820.png)

## 九、并发编程

### 1、线程模型

![image-20251210001342430](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210001342582.png)

#### 1.1 核心一句话总结

> **仓颉的轻量线程 = 用户线程（协程）
> runtime 会把大量协程调度到少量 OS 线程上执行
> 实现高并发、高效率的任务调度。**

也就是说：

- 你可以随便创建几十万用户线程（轻量线程）
- 底层只需要少量真正的系统线程来执行
- runtime 会自动调度、挂起、恢复协程

这就是 **M:N 线程模型**（多用户线程映射到少量系统线程）。

#### 1.2 什么是 M:N 轻量线程（User Threads）？

图中表示：

```
用户线程（绿色气泡）   M → 系统线程（黄色气泡） → CPU
```

含义：

- `M = 很多用户线程（协程）`
- `N = 很少的系统线程（OS threads）`
- runtime → 将 M 个用户线程映射到 N 个系统线程执行

例子：

```
10 万个用户线程
只用 4～8 个系统线程执行
```

runtime 负责调度 → 不需要你写任何代码管理线程。

------

####  1.3 为什么要这样设计？（对比传统线程模型）

传统 C++ / Java 模型：

- 创建线程很贵（几 MB 栈空间、系统调用）
- 上万个线程就能把系统干崩
- 内核调度开销大

仓颉的轻量线程：

- 每个用户线程占用极少内存（类似 Go 的 goroutine）
- 创建成本极低（几 KB 或更小）
- 切换和调度由 runtime 管理，不使用内核线程
- 可以创建百万级协程

这使得仓颉天生适合高并发 I/O、网络服务、模拟、任务流水线等应用。

------

#### 1.4. 轻量线程是如何调度的？

图下方解释了 runtime 的调度机制：

**当用户线程 t 做 I/O（例如访问文件或网络）时：**

- 如果 I/O **还没准备好**（例如需要等待）
- 线程 t **不会阻塞**系统线程！
- runtime 会：
  1. **挂起 t**
  2. 用系统线程去执行 **其他可运行的用户线程**

这叫做 **非阻塞调度**。

**当资源准备好后：**

- t 会被 runtime **恢复（唤醒）**
- 继续执行未完成的任务

这就实现了：

- 高并发
- 低线程切换成本
- 高 CPU 利用率

#### 1.5 总结

> 系统线程像是“公交车”，
> 用户线程（协程）是“乘客”。
>
> 公交车（OS 线程）数量不多，但能一次拉很多乘客（协程）。
>
> 当某个乘客要下车等朋友（I/O 等待），他会下车，但公交车不会停，会去接其他乘客。
>
> 等朋友来了，乘客再上另一辆车继续走。

runtime 就是“公交调度系统”。

### 2、创建线程

![image-20251210001611971](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210001612162.png)

下面我给你一个**结构清晰 + 通俗易懂**的解释，让你完全理解这页内容：
 它讲的是——**仓颉语言怎样用 `spawn` 创建线程，以及 Future 怎样获取线程结果。**

我会从概念 → 代码 → 图示流程 → 最终功能，逐步解释。

------

#### 2.1 spawn 的作用是什么？

> `spawn { ... }` 会创建一个新线程，并在线程中执行 `{ ... }` 里的代码。
>  `spawn` 表达式本身返回一个 **Future** ，用来代表“这个线程最终的返回值”。

------

#### 2.2 线程的返回值用 Future 表示

页面左下角定义了 `Future<T>`：

```cangjie
public class Future<T> {
    public func get(): T        // 等线程执行结束，返回线程结果
    public func get(ns: Int64): Option<T>   // 带超时的 get()
    public func tryGet(): Option<T>         // 不阻塞，尝试拿结果
    public func cancel(): Unit              // 请求取消该线程
    public prop thread: Thread              // 关联的线程对象
}
```

也就是说：

| 方法       | 含义                              |
| ---------- | --------------------------------- |
| `get()`    | 阻塞等待线程结束，并拿到返回结果  |
| `get(ns)`  | 最多等 ns 纳秒，超时返回 None     |
| `tryGet()` | 立即返回：要么是结果、要么是 None |
| `cancel()` | 请求取消线程                      |
| `thread`   | 获取实际对应的 Thread 实例        |



#### 2.3 spawn 创建线程的代码形式

语法：

```cangjie
spawn {
    blockFunc   // 在新线程中执行
}
```

对应类型为：

```
Future<T>     // T = blockFunc 的返回值类型
```

例如：

```cangjie
let f = spawn { return 123 }
```

此时：

- 新线程返回 123
- 在主线程可以调用 `f.get()` 得到 123

------

#### 2.4 右侧代码：用线程并行处理一张图像（中文版解释）

下面的流程是：**把图片分成 N 块 → 每块开一个线程 → 转灰度 → 合并保存。**

------

🔹 步骤 1：把图像切成 N 块

```cangjie
let blocks = image.split(N)
```

blocks 是一个数组，每个元素是图像的一块。

------

🔹 步骤 2：创建一个 Future 列表

```cangjie
let futures = ArrayList<Future<Unit>>()
```

每个线程都返回 Unit（void），所以 Future。

------

🔹 步骤 3：对每一块图片启动线程进行处理

```cangjie
for (block in blocks) {
    let future = spawn {
        for (i in 0..block.size) {
            let (r, g, b) = block[i]
            let gray = UInt8(0.299 * r + 0.587 * g + 0.114 * b)
            block[i] = (gray, gray, gray)  // 转成灰度
        }
    }
    futures.append(future)
}
```

解释：

- 内部 for 循环：对 block 的每个像素 (r,g,b) 做灰度转换
- `block[i] = (...)`：把像素写回 block
- spawn：每个 block 开一个线程来处理，因此是 N 个线程并行运行

这样能实现多核并行加速。

------

🔹 步骤 4：主线程等待所有线程结束

```cangjie
for (future in futures) {
    future.get()    // 等线程结束
}
```

这里调用 `get()`，主线程会阻塞，直到线程完成。

------

🔹 步骤 5：把所有灰度块重新组合回图像

```cangjie
blocks.toImage().save("gray.png")
```

------

**🎉 结果：得到灰度图**

右边有一个彩色图 → 并行处理成灰度图 → 保存输出。

------

#### 🧠 整页总结（最重要三句话）

**✔ 1. `spawn { ... }` 会开一个线程，并返回 Future**

Future 用来等待/取消线程、获取返回值。

**✔ 2. 多个 spawn 可以并行处理任务，实现多核加速**

就像例子把图像分块后用多个线程并行转灰度。

**✔ 3. `.get()` 会让主线程等待线程执行结束**

最终所有线程完成后，汇总结果保存图像。

### 3、应用示例

![image-20251210003130707](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210003130898.png)

#### 3.1 数学原理：用随机点估 π

核心想法就是经典的**蒙特卡洛方法估算圆周率**：

1. 画一个边长为 1 的正方形，里面画一个半径为 0.5 的圆（实际上是内切圆）。

2. 圆的面积：
   $$
    S_{\text{circle}} = \pi r^2 = \pi \times 0.5^2 = \frac{\pi}{4}
   $$

3. 正方形面积：
   $$
    S_{\text{square}} = 1 \times 1 = 1
   $$

4. 所以**圆在方形中占的面积比例**是：
   $$
   \frac{S_{\text{circle}}}{S_{\text{square}}} = \frac{\pi}{4}
   $$

如果我们在正方形里 **随机撒很多点**：

- 落在圆内的点数 / 总点数 ≈ 圆面积 / 正方形面积 = π/4

- 所以：
  $$
  \pi \approx 4 \times \frac{\text{圆内点数}}{\text{总点数}}
  $$

代码里 `(x - 0.5)^2 + (y - 0.5)^2 < 0.25` 就是在判定点 `(x,y)` 是否在这个半径 0.5、圆心在 (0.5, 0.5) 的圆内。

------

#### 3.2 多线程部分：加速“撒点”和计数

单线程做法就是：

- 循环 M⋅N 次
- 每次生成一个随机点
- 判断在不在圆里，统计个数
- 最后算 π

**这段代码做了两层优化：**

1. 把“撒 M 次点并统计命中数”封装成一个 `task()`，返回命中数量 `n_task`

2. 开 N 个线程，每个线程跑一次 `task()`

   - 每个线程独立撒 M 次点
   - 各自统计命中数

3. 主线程把 N 个 `task()` 的结果相加，得到总命中数 `n_total`

4. 总点数 = `M * N`
   $$
    \pi \approx 4 \times \frac{n_{\text{total}}}{M \times N}
   $$

**多线程的作用只是：**

> 把原来一大堆循环“拆成 N 份”，让多个 CPU 核心一起干活，从而在同样总点数下 **用更少时间** 得到结果。
>  精度由总点数 ($M \times N$ 决定，和“线程数”本身无关。

------

#### 3.3 误差 / 精度的直觉

- 总样本数 = `M * N`
- 蒙特卡洛估计的标准误差 ≈ $1/\sqrt{M \times N}$ 级别
- 想要多一位精度，需要样本数大概 ×100

所以：

- **M、N 越大 → 总点数越多 → π 越接近真实值 → deviation 越小**
- 多线程只是让你 **更快撒够这么多点**。

## 十、跨语言操作

### 1、跨语言互操作

![image-20251210003206667](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210003206839.png)

这页在讲 **仓颉做跨语言互操作的两种方式**：

- **接口式**（通过 Runtime / Engine 调用）
- **声明式**（通过 `extern` 直接声明外部函数）

------

#### 1.1 接口式（上半部分）

```cpp
auto runtime = XXLangEngine();
runtime.push(3.14);
runtime.call("process");
auto result = runtime.get(0).asBool();
```

含义：

- 宿主语言（这里像 C++）先创建一个“XXLang 运行时”对象 `runtime`
- 把参数 `3.14` 压入运行时（`push`）
- 调用目标语言里名字叫 `"process"` 的函数（`call("process")`）
- 从运行时里取回返回值（`get(0)`），再转换成 `bool`

特点：

- **宿主语言通过一个统一的“接口库 / Runtime”** 与目标语言交互
- 所有传参、调用、取返回值，都通过这个 runtime 对象来完成
- 更通用，但写起来会有一些样板代码（push / call / get）

------

#### 1.2 声明式（下半部分）

```cangjie
extern {
    bool process(float x)
}

...

auto result = process(3.14)
```

含义：

- 用 `extern { ... }` 告诉仓颉：

  > “外面有一个函数 `bool process(float)`，它是在别的语言里实现的（例如 C、ArkTS）。”

- 在仓颉代码中就可以 **像调用本地函数一样** 调用 `process(3.14)`，完成跨语言调用

特点：

- **宿主语言（仓颉）直接用自己的语法声明对方的函数签名**
- 编译器 / 链接器负责在目标程序里找到真正的实现
- 使用体验几乎和本地函数一样，调用非常自然

------

#### 1.3 总结一句话

> - **接口式**：通过一个运行时对象来“推参数 → 调函数 → 取结果”，更灵活、适合做脚本引擎式集成。
> - **声明式**：用 `extern` 声明外部函数，之后就像普通函数一样调用，语法最自然。
> - 仓颉当前支持和 C、ArkTS 等语言之间的 **声明式互操作**。

### 2、仓颉C互操作步骤

![image-20251210004136251](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210004136455.png)

### 3、类型映射

#### 3.1 基础类型

![image-20251210004257356](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210004257563.png)

#### 3.2 其他类型

![image-20251210004344074](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210004344309.png)

### 4、调用示例

![image-20251210004444927](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210004445140.png)



## 十一、宏

### 1、概述

![image-20251210004616500](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210004616717.png)

下面我给你一个**完整但不啰嗦的解释**，帮助你真正理解仓颉（Cangjie）中的 *宏（macro）机制* 是干什么的、怎么工作的。

------

#### 1.1 🧠 宏的核心作用：在“编译阶段”修改程序

仓颉提供“宏”，允许开发者在编译器处理源代码时 **介入编译流程**，
 读取部分编译信息，生成或修改 AST（抽象语法树）。

宏能做：

- 静态反射（读取类型/函数结构）
- 代码生成、插件化
- 语法扩展（比如 DSL）
- 优化、检查程序结构

宏并不会影响程序运行时，只在**编译时生效**。

------

#### 1.2 宏的使用方式

宏写在一个特殊的 package：

```cangjie
macro package xxx
```

编译成一个独立的动态库：

```bash
cjc example.cj --compile-macro
```

输出：

```
lib-macro_xxx.so
```

这个库 **在编译其他普通程序时被编译器加载**，协助“转换源代码”。

------

#### 1.3 宏的作用机制（图示部分解释）

图中展示了编译器的管线（pipeline）：

------

##### 1.3.1 🟦 普通 package 的编译流程：（无宏）

```
源码 → Parser → AST → 代码生成 → 可执行文件
```

很直观：源代码被解析成 AST，然后编译器继续处理。

------

##### 1.3.2 🟧 使用宏后的编译流程（重点）：

图中大框流程代表宏参与的位置：

1. **Parser 先解析普通代码**（得出 AST without macro）
2. **加载宏程序（transformer）**
   - 宏分析 AST
   - 宏有能力修改 AST、插入节点、生成新代码
3. **返回修改后的 AST**
4. 编译器根据修改后的 AST 继续生成最终目标代码

流程形式：

```
源码
   ↓
Parser（解析语法）
   ↓
原始 AST
   ↓
Macro transformer（执行宏，对 AST 进行修改）
   ↓
修改后的 AST
   ↓
Compiler backend → 输出可执行文件
```

------

##### 1.3.3🔍 关键点：宏运行在“编译器内部”，不是运行在用户程序中

图右说明：

> 宏程序也是仓颉写的，但它不是运行在最终程序中的代码，只在编译期间由编译器加载和执行。

所以宏不影响：

- 最终程序的运行速度
- 程序行为
- 程序大小（宏不会被打包进去）

------

#### 1.4🧩 为什么要设计宏？

编译阶段有大量信息（类型、结构、语法树…），
 宏允许开发者读取这些信息并“修改程序本身”。

这使得：

- 可以实现类似 Rust 的 Procedural Macro
- 可以构建自动代码生成器
- 可以做全局检查器（lint、规范检查）
- 可以在语法层面扩展仓颉语言

比如：

- 自动生成 getter/setter
- 自动生成序列化/反序列化
- 根据注解生成接口实现
- 静态检查某些规则（比如禁止魔法字符串）

------

#### 1.5🧱 最底部的小图：宏如何修改 AST？

底部的小图放大了“transformer”的机制：

```
Parser → tokens → transformer → Parser → AST
```

意思是：

1. 编译器把源代码解析成 **token 流**
2. 宏（transformer）接收到 token 流，可以：
   - 改写 token
   - 插入新 token
   - 删除 token
3. 编译器再次解析成 AST

这就是“语法扩展”的根本能力。

#### 1.6📌 总结一句话

> **仓颉宏 = 编译器插件 + AST 转换器 + 静态反射工具。**
>  它允许你在编译时查看与修改代码结构，实现插件化扩展、代码生成和静态分析。

### 2、定义与调用

![image-20251210005631975](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210005632209.png)

### 3、调用宏修改程序

![image-20251210005734807](https://gitee.com/zhang-junjie123/picture/raw/master/image/20251210005735117.png)

### 4、调用示例



下面我给你一个 **完整但非常清晰** 的解释，帮助你真正理解这一页：
 它展示的是——**如何用仓颉宏（macro）实现类似 C# LINQ 的语法扩展**。

------

#### 4.1 背景：C# 的 LINQ 是一种“语言级查询语法”

左侧是 C# 示例：

```csharp
var scoreQuery =
    from score in scores
    where score > 80
    select score;
```

C# 编译器会把上面的语法 **转换成普通的循环和判断**。

仓颉本身没有 LINQ，但 **通过宏可以自己把它扩展出来**。

------

#### 4.2 中间：仓颉用户写的代码（使用 LINQ 宏）

```cangjie
@LINQ(from score in scores where score > 80 select score)
```

`@LINQ(...)` 是一个**宏调用**，里面的内容不是普通语法，而是一段“自定义语法片段”。

仓颉编译器看到：

- 外面是宏 `@LINQ`
- 里面的 token（from … where … select …）全部会交给宏处理

宏的功能是：

> 读取这些 tokens → 分析语义 → 生成真正的仓颉代码

最终宏扩展后，相当于用户写的是：

```cangjie
for (score in scores) {
    if (score > 80) {
        println(score)
    }
}
```

所以效果与 C# LINQ 一样。

------

#### 4.3 右侧：宏 macro.cj 的核心逻辑（理解重点）

右边代码展示这个宏如何解析 token。

宏接收：

```cangjie
public macro LINQ(tokens: Tokens): Tokens
```

即：

- tokens = `from score in scores where score > 80 select score`
- 宏要自己解析这些 tokens

具体步骤：

------

##### ① 解析语法结构

```cangjie
let attribute = tokens[1]
let table     = tokens[3]
```

提取：

- `score`
- `scores`

------

##### ② 找到 where 和 select 的分界线

```cangjie
var index = 5
for (...) {
    if (tokens[i].value == "select") {
        index = i + 1
        break
    }
}
```

`condition` = where 后面的所有 tokens
 `select` = select 后面的所有 tokens

------

##### ③ 生成真实代码（返回 Tokens）

宏最后返回一个 quote：

```cangjie
return quote(
    for ($attribute in $table) {
        if ($condition) {
            println($select)
        }
    }
)
```

quote 表示“把这一段作为代码返回给编译器”。
 它使用 `$attribute` 等方式把前面解析的变量植入模板。

生成的最终代码类似：

```cangjie
for (score in scores) {
    if (score > 80) {
        println(score)
    }
}
```

这段代码才会被编译器进一步编译。

------

**效果：让仓颉拥有类似 C# LINQ 的语言能力**

输出：

```
97
92
81
```

完全等价于 C# LINQ。

------

#### 最后总结一句话

> **这个例子展示了仓颉宏可以在编译期修改代码结构，扩展语言语法，实现像 C# LINQ 这样的 DSL 功能。**

你不仅能在语言里使用新语法，还能完全自定义它的解析方式。这是“编译期元编程”的典型用途。
